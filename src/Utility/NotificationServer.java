package Utility;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * NotificationServer waits for a connection to be made, then creates a new
 * thread for handling the back and forth messaging between this server and the
 * client. This allows for the server to continue listening for other clients
 * trying to connect.
 * created: 11/23/18 by thf
 * last modified: 11/23/18 by thf
 * previously modified: 11/23/18 by thf (creation)
 * @author Tyler Fenske (thf)
 * @author Warren D. Craft (wdc)
 * @author Liam Brady (lb)
 */
public class NotificationServer implements Runnable {

    private ServerSocket serverSocket;
    //protected to allow for the child class "Notification" to access
    //the protocol
    protected PublicAuctionProtocol protocol;

    // ****************************** //
    //   Constructor(s)               //
    // ****************************** //

    /**
     * A server that creates a new thread for each connection made to the
     * server to allow for multiple synchronous client access.
     * @param portNumber port number used to host this server on.
     * @param protocol protocol for handling incoming messages.
     * @throws IOException
     */
    public NotificationServer(int portNumber, PublicAuctionProtocol protocol)
            throws IOException {
        serverSocket = new ServerSocket(portNumber);
        this.protocol = protocol;
    }

    // ****************************** //
    //   Override Fxns                //
    // ****************************** //

    /**
     * Waits for a socket connection request from client. Once a connection
     * is made, sends socket to a new thread for message passing â€” then
     * proceeds to wait for new incoming socket connection requests.
     */
    @Override
    public void run(){
        while(true){
            try{
                Socket clientSocket = serverSocket.accept();
                Notification notification = new Notification(clientSocket);
                Thread thread = new Thread(notification);
                thread.start();
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }

    /**
     * Provides encapsulated method for establishing the socket and
     * ObjectOutputStream & ObjectInputStream to a requesting client.
     * Used to receive incoming messages from clients, then send a response.
     * created: 11/23/18 by thf
     * last modified: 11/23/18 by thf
     * previously modified: 11/23/18 by thf (creation)
     * @author Tyler Fenske (thf)
     * @author Warren D. Craft (wdc)
     * @author Liam Brady (lb)
     */
    public class Notification implements Runnable{

        private Socket clientSocket;
        private ObjectOutputStream out;
        private ObjectInputStream in;

        // ****************************** //
        //   Constructor(s)               //
        // ****************************** //

        /**
         * Thread is created to handle message passing between a client
         * and this server.
         * @param clientSocket socket that holds the connection information
         *                     between the client and this server.
         * @throws IOException
         */
        public Notification(Socket clientSocket) throws IOException{
            this.clientSocket = clientSocket;
            out = new ObjectOutputStream(clientSocket.getOutputStream());
            out.flush();
            in = new ObjectInputStream(clientSocket.getInputStream());
        }

        // ****************************** //
        //   Override Fxns                //
        // ****************************** //

        /**
         * Repeatedly checks for an incoming message. Upon arrival of a new
         * message, sends the message to be handled through this servers
         * protocol, then replies to the message received with a message
         * generated by the aforementioned protocol.
         */
        @Override
        public void run(){
            Message receivedMessage = null;
            do{
                try{
                    receivedMessage = (Message) in.readObject();

                    Message replyMessage =
                            protocol.handleMessage(receivedMessage);

                    out.writeObject(replyMessage);
                    out.flush();
                    out.reset();

                }catch(ClassNotFoundException cnf){
                    cnf.printStackTrace();
                }catch(IOException io){
                    receivedMessage = null;
                }
            }while(receivedMessage != null);
        }
    }
}
